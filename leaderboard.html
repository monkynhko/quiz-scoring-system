<!DOCTYPE html>
<html lang="sk">
<head>
  <meta charset="UTF-8">
  <title>Quiz Leaderboard</title>
  <link rel="stylesheet" href="styles.css">
  <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2.39.7/dist/umd/supabase.min.js"></script>
  <style>
    .qr-container { text-align: right; margin-bottom: 1em; }
    .archive-list { margin-top: 2em; }
    .position-number { display:inline-block; width:36px; text-align:center; font-weight:700; color:#fff; background:transparent; }
    /* TV mode styles (16:9 projector target) - neon purple theme */
    :root { --tv-top-height: 28vh; --tv-gap: 10px; --neon:#b16cff; --neon-2:#7a3cff; }
    body.tv-mode { margin:0; background: linear-gradient(180deg,#0b0210,#140218); font-family: Inter, system-ui, -apple-system, "Segoe UI", Roboto, 'Helvetica Neue', Arial; color: #fff; }
    .tv-wrapper { box-sizing: border-box; width:100vw; height:100vh; padding:12px; display:flex; flex-direction:column; gap:var(--tv-gap); }
    /* Top 3 row */
    .tv-top-row { display:flex; gap:var(--tv-gap); height:var(--tv-top-height); }
    .tv-top { flex:1; display:flex; flex-direction:row; align-items:center; justify-content:space-between; border-radius:12px; padding:12px 18px; color:#fff; box-shadow:0 6px 30px rgba(138,43,226,0.12); }
    .tv-top--gold { background: linear-gradient(180deg, rgba(177,108,255,0.12), rgba(122,60,255,0.06)); border: 1px solid rgba(177,108,255,0.18); }
    .tv-top--silver { background: linear-gradient(180deg, rgba(122,60,255,0.08), rgba(122,60,255,0.02)); border: 1px solid rgba(122,60,255,0.12); }
    .tv-top--bronze { background: linear-gradient(180deg, rgba(122,60,255,0.06), rgba(177,108,255,0.02)); border: 1px solid rgba(122,60,255,0.10); }
    .tv-top .tv-rank-badge { font-weight:900; color:#111; background:var(--neon); padding:8px 12px; border-radius:10px; font-size:1.4rem; box-shadow:0 6px 18px rgba(177,108,255,0.18); margin-right:12px; }
    .tv-top .tv-team { font-weight:900; font-size:calc(2.0vh + 2.0vw); text-align:center; color:#fff; text-shadow:none; flex:1; }
    .tv-top .tv-score { font-size:calc(4.0vh + 3.0vw); font-weight:900; color:var(--neon); margin-left:12px; text-align:right; text-shadow:0 2px 12px rgba(177,108,255,0.12); }

    /* Grid for remaining teams (4 cols x 7 rows = 28) */
    .tv-grid { display:grid; grid-template-columns: repeat(4, 1fr); grid-auto-rows: calc((100vh - var(--tv-top-height) - 48px) / 7); gap:var(--tv-gap); flex:1; }
    .tv-tile { display:flex; flex-direction:row; align-items:center; justify-content:space-between; padding:12px 16px; border-radius:8px; background: linear-gradient(180deg, rgba(28,8,36,0.95), rgba(12,4,20,0.92)); border:1px solid rgba(255,255,255,0.04); color:#fff; box-shadow: 0 6px 22px rgba(40,10,80,0.18); overflow:hidden; position:relative; }
    .tv-tile .tv-team { font-weight:800; font-size:calc(1.6vh + 1.0vw); line-height:1.05; white-space:normal; display:-webkit-box; -webkit-line-clamp:2; -webkit-box-orient:vertical; overflow:hidden; text-overflow:ellipsis; text-align:center; flex:1; color:#fff; padding:0 12px; }
    .tv-tile .tv-score { font-size:calc(2.2vh + 1.6vw); font-weight:900; color:var(--neon); text-shadow:0 2px 10px rgba(177,108,255,0.08); margin-left:8px; min-width:4ch; text-align:right; }
    .tv-rank-badge { font-weight:900; color:#111; background:var(--neon); padding:6px 10px; border-radius:8px; font-size:1rem; box-shadow:0 4px 12px rgba(122,60,255,0.12); min-width:2.5ch; text-align:center; }

    /* Make columns 2 and 4 slightly lighter purple for better row contrast
       Keep team name and score colors unchanged as requested */
    .tv-grid .tv-tile:nth-child(4n+2),
    .tv-grid .tv-tile:nth-child(4n) {
      background: linear-gradient(180deg, rgba(80,36,120,0.92), rgba(40,18,80,0.90));
      border-color: rgba(220,180,255,0.06);
    }

    /* Minimal UI for TV mode: hide controls */
    body.tv-mode .view-controls, body.tv-mode .controls-row, body.tv-mode #archive-list-container { display:none !important; }
    body.tv-mode #leaderboard { width:100vw; max-width:none; margin:0; }
    body.tv-mode.hide-cursor { cursor:none; }

    /* Team name clickable */
    .team-name-clickable {
      cursor: pointer;
      transition: color 0.2s, text-decoration 0.2s;
    }
    .team-name-clickable:hover {
      color: #0ff;
      text-decoration: underline;
    }

    /* Team detail panel */
    .team-detail-panel {
      background: #12091e;
      border: 1px solid #333;
      border-radius: 10px;
      padding: 0 20px;
      margin: 4px 0 8px 0;
      overflow: hidden;
      max-height: 0;
      opacity: 0;
      transition: max-height 0.4s ease, opacity 0.3s ease, padding 0.3s ease;
    }
    .team-detail-panel.open {
      max-height: 600px;
      opacity: 1;
      padding: 16px 20px;
    }
    .team-detail-round {
      display: flex;
      flex-wrap: wrap;
      gap: 6px 16px;
      align-items: baseline;
      margin-bottom: 6px;
      font-size: 0.95em;
      color: #ddd;
    }
    .team-detail-round .round-label {
      font-weight: 700;
      color: #fff;
      min-width: 70px;
    }
    .team-detail-round .topic-score {
      color: #ccc;
    }
    .team-detail-round .round-sum {
      color: #ffd700;
      font-weight: 700;
      margin-left: auto;
    }
    .team-detail-best, .team-detail-worst {
      margin-top: 10px;
      font-size: 0.95em;
    }
    .team-detail-best { color: #0f0; }
    .team-detail-worst { color: #f66; }

    @media (max-width: 600px) {
      .team-detail-panel.open { padding: 12px 10px; }
      .team-detail-round { font-size: 0.85em; gap: 4px 8px; }
    }
  </style>
</head>
<body>
  <div style="width:100%; display:flex; flex-direction:column; align-items:center;">
    <div id="archive-list-container" style="width:100%; display:flex; flex-direction:column; align-items:center; justify-content:flex-start; margin-bottom:24px;">
      <!-- Dropdown sa vlo≈æ√≠ sem -->
    </div>
    <div id="leaderboard"></div>
    <div id="fallback" style="color: red; display: none; margin-top:16px;">
      Nepodarilo sa naƒç√≠ta≈• leaderboard z datab√°zy. Sk√∫≈°am fallback...
    </div>
  </div>
  <script>
  (function () {
    async function runApp() {
    // === SUPABASE KONFIG ===
    // NOTE: Do not commit real keys. Replace these placeholders with your values
    // or generate `config.js` from your `.env` using the provided script.
    // The page will use `window.SUPABASE_URL` / `window.SUPABASE_ANON_KEY` if `config.js` is present.
    let SUPABASE_URL = '<SUPABASE_URL_PLACEHOLDER>'; // e.g. https://xyz.supabase.co
    let SUPABASE_ANON_KEY = '<SUPABASE_ANON_KEY_PLACEHOLDER>';
    // Allow override from generated config.js (which sets window.SUPABASE_URL / window.SUPABASE_ANON_KEY)
    if (typeof window !== 'undefined' && window.SUPABASE_URL) {
      SUPABASE_URL = window.SUPABASE_URL;
    }
    if (typeof window !== 'undefined' && window.SUPABASE_ANON_KEY) {
      SUPABASE_ANON_KEY = window.SUPABASE_ANON_KEY;
    }
    const supabase = window.supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY);

    // If placeholders are present, show a clear message and skip auto-loading
    let SKIP_AUTO_LOAD = false;
    if (String(SUPABASE_URL).includes('<') || String(SUPABASE_ANON_KEY).includes('<')) {
      const board = document.getElementById('leaderboard');
      if (board) {
        board.innerHTML = `
          <div style="width:75vw; max-width:900px; margin:48px auto; padding:24px; background:#1a1333; color:#fff; border-radius:12px; text-align:center;">
            <h2 style="margin-bottom:12px;">Konfigur√°cia ch√Ωba</h2>
            <p style="margin-bottom:8px;">Supabase kƒæ√∫ƒçe nie s√∫ nakonfigurovan√©. Skop√≠rujte ` +
            `<code>env.example</code> do <code>.env</code> alebo vlo≈æte hodnoty do s√∫boru podƒæa README_SUPABASE.md.</p>
            <p style="font-size:0.95em; color:#ffd700;">Po nastaven√≠ kƒæ√∫ƒçov obnovte str√°nku.</p>
          </div>`;
      }
      SKIP_AUTO_LOAD = true;
    }

    // QR k√≥d odstr√°nen√Ω

    // Zisti quizId z URL
    const urlParams = new URLSearchParams(window.location.search);
    const quizId = urlParams.get('quizId');

    // === Interakt√≠vny dropdown na v√Ωber quizu ===
    function renderQuizDropdown(quizzes, onSelect, label = 'Vyber quiz:') {
      const root = document.getElementById('archive-list-container');
      // create view controls area (league / quiz) if missing
      let controlsArea = root.querySelector('.view-controls');
      if (!controlsArea) {
        controlsArea = document.createElement('div');
        controlsArea.className = 'view-controls';
        controlsArea.style = 'display:flex; align-items:center; justify-content:center; width:100%; margin-bottom:12px;';
        // create a single row matching leaderboard width: toggle centered, dropdown on right
        const controlsRow = document.createElement('div');
        controlsRow.className = 'controls-row';
        // make row centered and relatively positioned so dropdown can be absolutely placed to the right
        controlsRow.style = 'width:75vw; max-width:900px; display:flex; align-items:center; justify-content:center; margin:12px auto; position:relative;';

        // centered toggle wrapper
        const toggleWrapper = document.createElement('div');
        // give padding on the right so absolute-right dropdown won't overlap toggle text
        toggleWrapper.style = 'flex:1; display:flex; justify-content:center; padding-right:220px;';
        const toggleBtn = document.createElement('button');
        function updateToggleText() {
          toggleBtn.textContent = currentView === 'league' ? 'Zobrazi≈• aktu√°lny leaderboard' : 'Zobrazi≈• ligov√© sk√≥re';
        }
        updateToggleText();
        toggleBtn.className = 'neon-button';
        // make toggle full width of the controlsRow wrapper
        toggleBtn.style = 'width:100%; padding:12px 18px; font-size:1.05em; border-radius:12px; text-align:center; margin-right:10px;';
        toggleBtn.onclick = async () => {
          currentView = currentView === 'league' ? 'quiz' : 'league';
          updateToggleText();
          if (currentView === 'league') {
            await renderLeaderboard();
          } else {
            await renderLeaderboard(currentQuizId);
          }
        };
        toggleWrapper.appendChild(toggleBtn);

        // right-side placeholder for dropdown; will be filled below
        const rightArea = document.createElement('div');
        rightArea.className = 'controls-right';
        // absolutely position the dropdown to the right edge of the controlsRow
        rightArea.style = 'position:absolute; right:0; top:0; display:flex; align-items:center; gap:12px;';

        controlsRow.appendChild(toggleWrapper);
        controlsRow.appendChild(rightArea);
        controlsArea.appendChild(controlsRow);
        root.appendChild(controlsArea);
      }

      // dropdown area (separate so controlsArea isn't wiped)
      // find or create dropdown area inside the controls row's right area
      let dropdownArea = root.querySelector('.controls-right .dropdown-area');
      if (!dropdownArea) {
        const rightArea = root.querySelector('.controls-right');
        dropdownArea = document.createElement('div');
        dropdownArea.className = 'dropdown-area';
        dropdownArea.style = 'display:flex; align-items:center; gap:12px;';
        if (rightArea) rightArea.appendChild(dropdownArea); else root.appendChild(dropdownArea);
      }

      // remove only the quiz dropdown (preserve season dropdown if present)
      let old = dropdownArea.querySelector('#quizDropdown');
      if (old) old.remove();
      const container = document.createElement('div');
      container.id = 'quizDropdown';
      container.style = 'display:flex; align-items:center; gap:12px;';
      const lbl = document.createElement('label');
      lbl.textContent = 'Kv√≠zy:';
      lbl.style = 'font-weight:bold; font-size:1.1em; color:#0ff; margin-right:8px;';
      container.appendChild(lbl);
      const select = document.createElement('select');
      select.style = 'padding:8px 16px; font-size:1.1em; border-radius:12px; border:1px solid #0ff; background:#222; color:#0ff; margin-right:12px;';
      quizzes.forEach(q => {
        const option = document.createElement('option');
        option.value = q.id;
        // show only the quiz title (no created_at timestamp)
        option.textContent = q.title || (q.created_at?.slice(0,10) || 'Untitled');
        select.appendChild(option);
      });
      // ensure the dropdown shows the currently selected quiz (if any)
      try {
        if (currentQuizId) {
          select.value = currentQuizId;
        } else if (select.options.length) {
          // default to the first option
          select.value = select.options[0].value;
        }
      } catch (e) {
        // ignore if value not present
      }
      container.appendChild(select);
      // automatically show selected quiz when changed (remove explicit "Zobrazi≈•" button)
      select.addEventListener('change', () => {
        onSelect(select.value);
      });
      dropdownArea.appendChild(container);
    }

    let currentQuizId = quizId;
    let currentView = 'quiz'; // 'quiz' or 'league'
    // Season state: will hold the currently selected season id
    let currentSeasonId = null;

    // Render a seasons dropdown next to the quiz dropdown
    function renderSeasonDropdown(seasons, onSelect) {
      const root = document.getElementById('archive-list-container');
      let dropdownArea = root.querySelector('.controls-right .dropdown-area');
      if (!dropdownArea) {
        const rightArea = root.querySelector('.controls-right');
        dropdownArea = document.createElement('div');
        dropdownArea.className = 'dropdown-area';
        dropdownArea.style = 'display:flex; align-items:center; gap:12px;';
        if (rightArea) rightArea.appendChild(dropdownArea); else root.appendChild(dropdownArea);
      }

      // create or replace season dropdown
      let old = document.getElementById('seasonDropdown');
      if (old) old.remove();
      const container = document.createElement('div');
      container.id = 'seasonDropdown';
      container.style = 'display:flex; align-items:center; gap:8px;';
      const lbl = document.createElement('label');
      lbl.textContent = 'Sez√≥na:';
      lbl.style = 'font-weight:bold; font-size:1.1em; color:#0ff; margin-right:8px;';
      container.appendChild(lbl);
      const select = document.createElement('select');
      select.id = 'seasonSelect';
      select.style = 'padding:8px 12px; font-size:1.05em; border-radius:10px; border:1px solid #0ff; background:#222; color:#0ff;';
      // ensure select is wide enough to show long season names
      select.style.minWidth = '160px';
      select.style.boxSizing = 'border-box';
      (seasons || []).forEach(s => {
        const opt = document.createElement('option');
        opt.value = s.id;
        opt.textContent = s.name || (s.id || 'Unknown');
        if (s.is_active) opt.dataset.active = '1';
        select.appendChild(opt);
      });
      // try to set current selection
      try {
        console.log('renderSeasonDropdown: seasons', seasons);
        if (currentSeasonId) select.value = currentSeasonId;
        else {
          const activeOpt = select.querySelector('option[data-active="1"]');
          if (activeOpt) select.value = activeOpt.value; else if (select.options.length) select.value = select.options[0].value;
        }
        console.log('renderSeasonDropdown: selected', select.value, 'text', select.options[select.selectedIndex] && select.options[select.selectedIndex].text);
      } catch (e) { console.warn('season select set value failed', e); }
      select.addEventListener('change', async () => {
        currentSeasonId = select.value;
        console.log('season changed to', currentSeasonId);
        if (typeof onSelect === 'function') await onSelect(select.value);
      });
      container.appendChild(select);
      // place season dropdown to the left of quiz dropdown by prepending
      dropdownArea.insertBefore(container, dropdownArea.firstChild || null);
    }

    async function renderLeaderboard(quizIdOverride) {
      let data;
      try {
        let idToUse = quizIdOverride || currentQuizId;
        // If league view selected, fetch aggregated league across quizzes
        if (currentView === 'league') {
          const leagueData = await fetchLeague();
          renderLeagueTable(leagueData);
          await renderArchive();
          return;
        }
        // Ak nie je quizId, automaticky zober najnov≈°√≠ quiz
        if (!idToUse) {
          const { data: quiz } = await supabase
            .from('quizzes')
            .select('id, title, created_at')
            .order('created_at', { ascending: false })
            .limit(1)
            .single();
          if (!quiz) throw new Error('≈Ωiadny quiz');
          idToUse = quiz.id;
        }
        // Fetch konkr√©tny quiz
        const { data: quiz } = await supabase
          .from('quizzes')
          .select('id, title, created_at')
          .eq('id', idToUse)
          .single();
        if (!quiz) throw new Error('Quiz nen√°jden√Ω');
    data = await fetchLeaderboardForQuiz(quiz.id);
    // strip trailing parenthetical timestamp from quiz title for display
    const displayQuizTitle = (quiz.title || '').replace(/\s*\(.*\)$/, '');
    data.quizTitle = displayQuizTitle;
  renderTable(data);
  await renderArchive();
      } catch (e) {
        document.getElementById('fallback').style.display = '';
        // Fallback: naƒç√≠taj leaderboard.json
        try {
          const resp = await fetch('leaderboard.json');
          if (!resp.ok) throw new Error('Chyba naƒç√≠tania snapshotu');
          const snapshot = await resp.json();
          renderTable(snapshot);
        } catch (e2) {
          document.getElementById('leaderboard').innerHTML =
            '<p>Leaderboard nie je dostupn√Ω.</p>';
        }
      }
    }

    // --- Helper: normalize team names (remove diacritics + lowercase) ---
    function normalizeTeamName(name) {
      if (!name) return '';
      try {
        // decompose diacritics and remove combining marks
        return name.normalize('NFD').replace(/[\u0300-\u036f]/g, '')
          .toLowerCase()
          .trim();
      } catch (e) {
        // Fallback simple normalization
        return name.replace(/[\u0300-\u036f]/g, '').toLowerCase().trim();
      }
    }

    // --- League aggregation: sum points by normalized team name across quizzes in the current season ---
    async function fetchLeague() {
      // determine quizzes that belong to the selected season
      let { data: seasonQuizzes } = await supabase
        .from('quizzes')
        .select('id, created_at')
        .order('created_at', { ascending: false });
      if (currentSeasonId) {
        const res = await supabase.from('quizzes').select('id, created_at').eq('season_id', currentSeasonId).order('created_at', { ascending: false });
        seasonQuizzes = res.data;
      }
      const quizIds = (seasonQuizzes || []).map(q => q.id).filter(Boolean);
      if (!quizIds.length) return { league: [] };

      // fetch teams that appeared in these quizzes
      const { data: teams } = await supabase
        .from('teams')
        .select('id, name, quiz_id')
        .in('quiz_id', quizIds);

      // fetch rounds for those quizzes
      const { data: rounds } = await supabase
        .from('rounds')
        .select('id, quiz_id')
        .in('quiz_id', quizIds);
      const roundIds = (rounds || []).map(r => r.id).filter(Boolean);
      
      // Try topic_scores first (new system)
      let useTopicScores = false;
      let roundTopicsData = [];
      let topicScoresData = [];
      if (roundIds.length) {
        const { data: rtData } = await supabase
          .from('round_topics')
          .select('id, round_id')
          .in('round_id', roundIds);
        roundTopicsData = rtData || [];
        if (roundTopicsData.length) {
          useTopicScores = true;
          const rtIds = roundTopicsData.map(rt => rt.id);
          const { data: tsData } = await supabase
            .from('topic_scores')
            .select('team_id, round_topic_id, score')
            .in('round_topic_id', rtIds);
          topicScoresData = tsData || [];
        }
      }
      
      // Also fetch legacy scores
      const { data: scores } = roundIds.length ? await supabase
        .from('scores')
        .select('team_id, score, round_id')
        .in('round_id', roundIds) : { data: [] };

      const teamById = {};
      (teams || []).forEach(t => { teamById[t.id] = t; });
      
      // Build per-quiz scoremap for momentum
      const quizTeamTotals = {}; // { quizId: { norm: total } }
      quizIds.forEach(qid => { quizTeamTotals[qid] = {}; });

      // Aggregate by normalized name
      const agg = {}; // norm -> { total, appearancesSet, nameCounts, firstSeen, quizTotals[] }
      
      if (useTopicScores && topicScoresData.length) {
        // Map round_topic -> round -> quiz
        const rtToRound = {};
        roundTopicsData.forEach(rt => { rtToRound[rt.id] = rt.round_id; });
        const roundToQuiz = {};
        (rounds || []).forEach(r => { roundToQuiz[r.id] = r.quiz_id; });
        
        topicScoresData.forEach(ts => {
          const teamId = ts.team_id;
          const team = teamById[teamId];
          if (!team) return;
          const original = (team.name || 'Unknown').trim();
          const norm = normalizeTeamName(original) || original.toLowerCase();
          if (!agg[norm]) agg[norm] = { total: 0, appearancesSet: new Set(), nameCounts: {}, firstSeen: original, quizTotals: {} };
          const scoreVal = Number(ts.score) || 0;
          agg[norm].total += scoreVal;
          agg[norm].appearancesSet.add(team.quiz_id);
          agg[norm].nameCounts[original] = (agg[norm].nameCounts[original] || 0) + 1;
          // Per-quiz total
          const roundId = rtToRound[ts.round_topic_id];
          const quizId = roundToQuiz[roundId];
          if (quizId) {
            if (!agg[norm].quizTotals[quizId]) agg[norm].quizTotals[quizId] = 0;
            agg[norm].quizTotals[quizId] += scoreVal;
          }
        });
      } else {
        // Legacy scores
        const roundToQuiz = {};
        (rounds || []).forEach(r => { roundToQuiz[r.id] = r.quiz_id; });
        
        (scores || []).forEach(s => {
          const teamId = s.team_id;
          const team = teamById[teamId];
          if (!team) return;
          const original = (team.name || 'Unknown').trim();
          const norm = normalizeTeamName(original) || original.toLowerCase();
          if (!agg[norm]) agg[norm] = { total: 0, appearancesSet: new Set(), nameCounts: {}, firstSeen: original, quizTotals: {} };
          const scoreVal = Number(s.score) || 0;
          agg[norm].total += scoreVal;
          agg[norm].appearancesSet.add(team.quiz_id);
          agg[norm].nameCounts[original] = (agg[norm].nameCounts[original] || 0) + 1;
          const quizId = roundToQuiz[s.round_id];
          if (quizId) {
            if (!agg[norm].quizTotals[quizId]) agg[norm].quizTotals[quizId] = 0;
            agg[norm].quizTotals[quizId] += scoreVal;
          }
        });
      }

      // Sort quizzes by date (recent first) for momentum calculation
      const sortedQuizzes = (seasonQuizzes || []).sort((a, b) => new Date(b.created_at) - new Date(a.created_at));
      
      const league = Object.keys(agg).map(norm => {
        const entry = agg[norm];
        const names = Object.keys(entry.nameCounts);
        names.sort((a, b) => entry.nameCounts[b] - entry.nameCounts[a]);
        const displayName = names[0] || entry.firstSeen || norm;
        
        // Momentum: compare average of last 3 quizzes vs previous quizzes
        let momentum = null; // null = not enough data
        const quizTotals = entry.quizTotals;
        const quizScoresByDate = sortedQuizzes
          .filter(q => quizTotals[q.id] !== undefined)
          .map(q => quizTotals[q.id]);
        
        if (quizScoresByDate.length >= 2) {
          const recent = quizScoresByDate.slice(0, Math.min(3, quizScoresByDate.length));
          const older = quizScoresByDate.slice(Math.min(3, quizScoresByDate.length));
          const recentAvg = recent.reduce((a, b) => a + b, 0) / recent.length;
          const olderAvg = older.length > 0 ? older.reduce((a, b) => a + b, 0) / older.length : recentAvg;
          if (recentAvg > olderAvg * 1.05) momentum = 'up';
          else if (recentAvg < olderAvg * 0.95) momentum = 'down';
          else momentum = 'stable';
        }
        
        return { team: displayName, total: entry.total, appearances: entry.appearancesSet.size, momentum };
      }).sort((a, b) => b.total - a.total);

      return { league };
    }

    function renderLeagueTable(data) {
      const list = (data && data.league) || [];
      if (!list.length) {
        document.getElementById('leaderboard').innerHTML = '<p>≈Ωiadne ligov√© d√°ta.</p>';
        return;
      }
      const hasMomentum = list.some(r => r.momentum !== null && r.momentum !== undefined);
      let html = `<div class="leaderboard-modern single-col">
        <div class="leaderboard-header">Liga - S√∫ƒçet bodov</div>
        <div class="leaderboard-col" style="width:75vw; max-width:900px; margin:0 auto;">
          <div class="leaderboard-row leaderboard-row-header">
            <div class="leaderboard-cell">&nbsp;</div>
            <div class="leaderboard-cell">T√≠m</div>
            <div class='leaderboard-cell'>√öƒçasti</div>
            ${hasMomentum ? '<div class="leaderboard-cell">Forma</div>' : ''}
            <div class='leaderboard-cell'>S√∫ƒçet</div>
          </div>`;
      list.forEach((row, i) => {
        let momentumHtml = '';
        if (hasMomentum) {
          if (row.momentum === 'up') momentumHtml = '<div class="leaderboard-cell"><span class="momentum-up" title="St√∫paj√∫ca forma">üî∫</span></div>';
          else if (row.momentum === 'down') momentumHtml = '<div class="leaderboard-cell"><span class="momentum-down" title="Klesaj√∫ca forma">üîª</span></div>';
          else if (row.momentum === 'stable') momentumHtml = '<div class="leaderboard-cell"><span class="momentum-stable" title="Stabiln√° forma">‚ûñ</span></div>';
          else momentumHtml = '<div class="leaderboard-cell">-</div>';
        }
        html += `<div class="leaderboard-row${i < 3 ? ' leaderboard-top' : ''}">
          <div class="leaderboard-cell">${i < 3 ? ['ü•á','ü•à','ü•â'][i] : '<span class="position-number">'+(i+1)+'</span>'}</div>
          <div class="leaderboard-cell">${row.team}</div>
          <div class='leaderboard-cell'>${row.appearances}</div>
          ${momentumHtml}
          <div class='leaderboard-cell total-score-cell'><b>${row.total}</b></div>
        </div>`;
      });
      html += '</div></div>';
      document.getElementById('leaderboard').innerHTML = html;
    }

    async function fetchLeaderboardForQuiz(quizId) {
      const { data: teams, error: teamsError } = await supabase
        .from('teams')
        .select('id, name')
        .eq('quiz_id', quizId);
      const { data: rounds, error: roundsError } = await supabase
        .from('rounds')
        .select('id, name, round_order')
        .eq('quiz_id', quizId)
        .order('round_order');
      
      // Fetch round_topics for topic-based scoring
      const roundIds = (rounds || []).map(r => r.id);
      let roundTopicsData = [];
      if (roundIds.length) {
        const { data: rtData } = await supabase
          .from('round_topics')
          .select('id, round_id, category_id, topic_order, max_points')
          .in('round_id', roundIds)
          .order('topic_order');
        roundTopicsData = rtData || [];
      }
      
      // Fetch categories for names/icons
      const categoryIds = [...new Set(roundTopicsData.filter(rt => rt.category_id).map(rt => rt.category_id))];
      let categoriesMap = {};
      if (categoryIds.length) {
        const { data: cats } = await supabase
          .from('categories')
          .select('id, name, icon')
          .in('id', categoryIds);
        (cats || []).forEach(c => { categoriesMap[c.id] = c; });
      }
      
      const hasTopics = roundTopicsData.length > 0;
      
      // Fetch topic_scores if available
      const rtIds = roundTopicsData.map(rt => rt.id);
      let topicScoresData = [];
      if (rtIds.length) {
        const { data: tsData } = await supabase
          .from('topic_scores')
          .select('team_id, round_topic_id, score')
          .in('round_topic_id', rtIds);
        topicScoresData = tsData || [];
      }
      
      // Also fetch legacy scores for backward compat
      const { data: scores, error: scoresError } = await supabase
        .from('scores')
        .select('team_id, round_id, score');
      
      // Build enriched round info with topics
      const enrichedRounds = (rounds || []).map(round => {
        const topics = roundTopicsData
          .filter(rt => rt.round_id === round.id)
          .sort((a, b) => a.topic_order - b.topic_order)
          .map(rt => {
            const cat = categoriesMap[rt.category_id];
            return {
              id: rt.id,
              categoryId: rt.category_id,
              categoryName: cat ? cat.name : 'Unknown',
              categoryIcon: cat ? (cat.icon || '') : '‚ùì',
              topicOrder: rt.topic_order,
              maxPoints: rt.max_points || 5,
              customName: null
            };
          });
        return { ...round, topics };
      });
      
      // Build leaderboard data
      const leaderboard = (teams || []).map(team => {
        let total = 0;
        let roundScores = [];
        let topicDetails = []; // [{roundName, topics: [{name, icon, score, max}]}]
        
        enrichedRounds.forEach(round => {
          if (hasTopics && round.topics.length) {
            let roundTotal = 0;
            const topicScoresForRound = round.topics.map(topic => {
              const ts = topicScoresData.find(ts => ts.team_id === team.id && ts.round_topic_id === topic.id);
              const score = ts ? Number(ts.score) : 0;
              roundTotal += score;
              return {
                name: topic.categoryName,
                icon: topic.categoryIcon,
                score,
                max: topic.maxPoints
              };
            });
            total += roundTotal;
            roundScores.push(roundTotal);
            topicDetails.push({ roundName: round.name, topics: topicScoresForRound });
          } else {
            // Legacy fallback
            const s = (scores || []).find(sc => sc.team_id === team.id && sc.round_id === round.id);
            const score = s ? Number(s.score) : 0;
            total += score;
            roundScores.push(score);
            topicDetails.push({ roundName: round.name, topics: [] });
          }
        });
        return { team: team.name, teamId: team.id, total, roundScores, topicDetails };
      });
      leaderboard.sort((a, b) => b.total - a.total);

      // ≈†tatistiky
      let stats = {
        topScore: { team: '', score: 0 },
        easiestRound: { round: '', avgScore: 0 },
        hardestRound: { round: '', avgScore: Infinity },
        bestRound: { team: '', round: '', score: 0 }
      };
      
      // Round winners
      let roundWinners = [];
      
      enrichedRounds.forEach(round => {
        let roundTotal = 0;
        let bestTeams = [];
        let bestScore = -1;
        (teams || []).forEach(team => {
          let teamRoundScore = 0;
          if (hasTopics && round.topics.length) {
            round.topics.forEach(topic => {
              const ts = topicScoresData.find(ts => ts.team_id === team.id && ts.round_topic_id === topic.id);
              teamRoundScore += ts ? Number(ts.score) : 0;
            });
          } else {
            const s = (scores || []).find(sc => sc.team_id === team.id && sc.round_id === round.id);
            teamRoundScore = s ? Number(s.score) : 0;
          }
          roundTotal += teamRoundScore;
          if (teamRoundScore > bestScore) {
            bestScore = teamRoundScore;
            bestTeams = [team.name];
          } else if (teamRoundScore === bestScore && bestScore > 0) {
            bestTeams.push(team.name);
          }
          if (teamRoundScore > stats.bestRound.score) {
            stats.bestRound = { team: team.name, round: round.name, score: teamRoundScore };
          }
        });
        const avgScore = roundTotal / (teams?.length || 1);
        if (avgScore > stats.easiestRound.avgScore) {
          stats.easiestRound = { round: round.name, avgScore };
        }
        if (avgScore < stats.hardestRound.avgScore) {
          stats.hardestRound = { round: round.name, avgScore };
        }
        roundWinners.push({ round: round.name, teams: bestTeams, score: bestScore });
      });
      leaderboard.forEach(row => {
        if (row.total > stats.topScore.score) {
          stats.topScore = { team: row.team, score: row.total };
        }
      });
      
      // Category statistics
      let categoryStats = {};
      if (hasTopics) {
        roundTopicsData.forEach(rt => {
          const cat = categoriesMap[rt.category_id];
          const catName = cat ? cat.name : 'Other';
          const catIcon = cat ? (cat.icon || '') : '‚ùì';
          if (!categoryStats[catName]) {
            categoryStats[catName] = { icon: catIcon, totalScore: 0, maxPossible: 0, count: 0, teamScores: {} };
          }
          (teams || []).forEach(team => {
            const ts = topicScoresData.find(ts => ts.team_id === team.id && ts.round_topic_id === rt.id);
            const score = ts ? Number(ts.score) : 0;
            categoryStats[catName].totalScore += score;
            categoryStats[catName].maxPossible += (rt.max_points || 5);
            categoryStats[catName].count++;
            if (!categoryStats[catName].teamScores[team.name]) {
              categoryStats[catName].teamScores[team.name] = { total: 0, max: 0 };
            }
            categoryStats[catName].teamScores[team.name].total += score;
            categoryStats[catName].teamScores[team.name].max += (rt.max_points || 5);
          });
        });
      }
      
      return { leaderboard, rounds: enrichedRounds, stats, roundWinners, categoryStats, hasTopics };
    }

    // Build expandable detail HTML for a single team row
    function renderTeamDetailHtml(row, escapeHtml) {
      const details = row.topicDetails || [];
      if (!details.length || !details.some(d => d.topics && d.topics.length)) {
        return '<div style="color:#888; font-size:0.9em;">≈Ωiadne detailn√© d√°ta pre tento t√≠m.</div>';
      }
      let h = '<div style="font-size:1.05em; font-weight:700; color:#fff; margin-bottom:10px;">üìä ' + escapeHtml(row.team) + ' ‚Äî Detailn√© v√Ωsledky</div>';
      // Per-round breakdown
      details.forEach((rd, idx) => {
        const topics = rd.topics || [];
        const roundTotal = (row.roundScores && row.roundScores[idx]) || topics.reduce((s,t) => s + (t.score||0), 0);
        h += '<div class="team-detail-round">';
        h += '<span class="round-label">Kolo ' + (idx+1) + ':</span> ';
        topics.forEach((t, ti) => {
          const pct = t.max > 0 ? Math.round((t.score / t.max) * 100) : 0;
          h += '<span class="topic-score">' + (t.icon || '') + ' ' + escapeHtml(t.name) + ' ' + t.score + '/' + t.max + '</span>';
          if (ti < topics.length - 1) h += '<span style="color:#555;"> | </span>';
        });
        h += '<span class="round-sum">= ' + roundTotal + ' b.</span>';
        h += '</div>';
      });
      // Best / worst topic
      let allTopics = [];
      details.forEach(rd => {
        (rd.topics || []).forEach(t => {
          if (t.max > 0) allTopics.push(t);
        });
      });
      if (allTopics.length) {
        allTopics.sort((a, b) => (b.score / b.max) - (a.score / a.max));
        const best = allTopics[0];
        const worst = allTopics[allTopics.length - 1];
        const bestPct = Math.round((best.score / best.max) * 100);
        const worstPct = Math.round((worst.score / worst.max) * 100);
        h += '<div class="team-detail-best">üìà Najlep≈°ia t√©ma: ' + (best.icon||'') + ' ' + escapeHtml(best.name) + ' (' + best.score + '/' + best.max + ' = ' + bestPct + '%)</div>';
        h += '<div class="team-detail-worst">üìâ Najslab≈°ia t√©ma: ' + (worst.icon||'') + ' ' + escapeHtml(worst.name) + ' (' + worst.score + '/' + worst.max + ' = ' + worstPct + '%)</div>';
      }
      return h;
    }

    function renderTable(data) {
      function escapeHtml(s) {
        return String(s).replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;').replace(/'/g, '&#39;');
      }
      const quizTitle = (data && data.quizTitle) || '';
      if (!data || !data.leaderboard) {
        document.getElementById('leaderboard').innerHTML = '<p>≈Ωiadne d√°ta.</p>';
        return;
      }
      const medals = [
        '<span class="medal gold" style="color:#FFD700;" title="1. miesto">ü•á</span>',
        '<span class="medal silver" style="color:#C0C0C0;" title="2. miesto">ü•à</span>',
        '<span class="medal bronze" style="color:#CD7F32;" title="3. miesto">ü•â</span>'
      ];
      
      let html = `<div class="leaderboard-modern single-col">
        <div class="leaderboard-header">Leaderboard${quizTitle ? ' - ' + escapeHtml(quizTitle) : ''}</div>
        <div class="leaderboard-col" style="width:75vw; max-width:900px; margin:0 auto;">`;
      
      // Always use single-row header with round totals (5-column format)
      html += `<div class="leaderboard-row leaderboard-row-header">
            <div class="leaderboard-cell">&nbsp;</div>
            <div class="leaderboard-cell">T√≠m</div>
            ${(data.rounds||[]).map((r, idx) => `<div class='leaderboard-cell round-score-header'>${idx+1}. kolo</div>`).join('')}
             <div class='leaderboard-cell total-score-header'>S√∫ƒçet</div>
          </div>`;
      
      // Data rows ‚Äî always show roundScores (sum per round), team name is clickable
      data.leaderboard.forEach((row, i) => {
        const rowId = 'team-detail-' + i;
        html += `<div class="leaderboard-row${i < 3 ? ' leaderboard-top' : ''}">
          <div class="leaderboard-cell">${i < 3 ? medals[i] : '<span class="position-number">'+(i+1)+'</span>'}</div>
          <div class="leaderboard-cell"><span class="team-name-clickable" data-team-idx="${i}">${escapeHtml(row.team)}</span></div>`;
        (row.roundScores||[]).forEach(score => {
          html += `<div class='leaderboard-cell round-score-cell'>${score}</div>`;
        });
        html += `<div class='leaderboard-cell total-score-cell'><b>${row.total}</b></div>
        </div>`;
        // Hidden detail panel right after the row
        html += `<div id="${rowId}" class="team-detail-panel">${renderTeamDetailHtml(row, escapeHtml)}</div>`;
      });
      html += '</div>';
      
      // Round Winners section
      if (data.roundWinners && data.roundWinners.length) {
        html += `<div style="margin-top:24px; width:75vw; max-width:900px;">
          <h3 style="color:#ffd700; text-align:center; margin-bottom:12px;">üèÜ V√≠≈•azi k√¥l</h3>
          <div style="display:flex; flex-wrap:wrap; gap:12px; justify-content:center;">`;
        data.roundWinners.forEach((rw, idx) => {
          const winnerNames = (rw.teams || [rw.team]).map(t => escapeHtml(t));
          html += `<div style="background:#1a1333; border:1px solid #333; border-radius:10px; padding:10px 16px; text-align:center; min-width:140px;">
            <div style="font-size:0.85em; color:#aaa;">${idx + 1}. kolo</div>
            ${winnerNames.map(n => `<div style="font-weight:bold; color:#fff; margin:4px 0;">${n}</div>`).join('')}
            <div style="color:#ffd700; font-weight:bold;">${rw.score} b.</div>
          </div>`;
        });
        html += '</div></div>';
      }
      
      // Category Statistics section (simplified: overall average + best team only)
      if (data.categoryStats && Object.keys(data.categoryStats).length) {
        html += `<div style="margin-top:32px; width:75vw; max-width:900px;">
          <h3 style="color:#0ff; text-align:center; margin-bottom:16px;">üìä ≈†tatistiky podƒæa kateg√≥ri√≠</h3>
          <div style="display:flex; flex-wrap:wrap; gap:16px; justify-content:center;">`;
        Object.entries(data.categoryStats).forEach(([catName, catData]) => {
          const pct = catData.maxPossible > 0 ? Math.round((catData.totalScore / catData.maxPossible) * 100) : 0;
          // Compute average per team (use number of teams present in teamScores)
          const teamScores = catData.teamScores || {};
          const numberOfTeams = Math.max(1, Object.keys(teamScores).length);
          const avgPerTeam = (catData.totalScore / numberOfTeams) || 0;
          const avgMaxPerTeam = (catData.maxPossible / numberOfTeams) || 0;
          // Find best score and collect all teams that reached it
          let bestScore = -Infinity;
          Object.entries(teamScores).forEach(([team, ts]) => {
            const val = Number(ts.total) || 0;
            if (val > bestScore) bestScore = val;
          });
          const winners = [];
          Object.entries(teamScores).forEach(([team, ts]) => {
            const val = Number(ts.total) || 0;
            if (val === bestScore) winners.push(team);
          });
          const winnersText = winners.length === 1
            ? `üèÜ V√≠≈•az: ${escapeHtml(winners[0])} (${bestScore})`
            : `üèÜ V√≠≈•azi: ${winners.map(w => escapeHtml(w)).join(', ')} (${bestScore})`;

          html += `<div class="category-stat-card" style="background:#1a1333; border:1px solid #333; border-radius:12px; padding:14px 18px; min-width:200px; max-width:280px; flex:1;">
            <div style="font-size:1.2em; margin-bottom:6px;">${catData.icon || ''} <strong>${escapeHtml(catName)}</strong></div>
            <div class="progress-bar-container" style="background:#222; border-radius:6px; height:14px; margin:8px 0; overflow:hidden;">
              <div style="background:linear-gradient(90deg,#0ff,#ff00ff); height:100%; width:${pct}%; border-radius:6px; transition:width 0.5s;"></div>
            </div>
            <div style="font-size:0.85em; color:#aaa;">Priemer: ${avgPerTeam.toFixed(1)} / ${avgMaxPerTeam.toFixed(1)}</div>
            ${winners.length ? `<div style="font-size:0.85em; color:#ffd700; margin-top:4px;">${winnersText}</div>` : ''}
          </div>`;
        });
        html += '</div></div>';
      }
      
      html += '</div>';
      document.getElementById('leaderboard').innerHTML = html;

      // Attach click handlers for team detail panels
      document.querySelectorAll('.team-name-clickable').forEach(el => {
        el.addEventListener('click', function () {
          const idx = this.getAttribute('data-team-idx');
          const panel = document.getElementById('team-detail-' + idx);
          if (!panel) return;
          const isOpen = panel.classList.contains('open');
          // Close all open panels first
          document.querySelectorAll('.team-detail-panel.open').forEach(p => p.classList.remove('open'));
          // Toggle clicked panel
          if (!isOpen) panel.classList.add('open');
        });
      });
    }

    function renderStatistics(data) {
      if (!data || !data.stats) return;
      document.getElementById('topScore').textContent = `${data.stats.topScore.team} (${data.stats.topScore.score} bodov)`;
      document.getElementById('easiestRound').textContent = `${data.stats.easiestRound.round} (${Math.round(data.stats.easiestRound.avgScore)} bodov priemer)`;
      document.getElementById('hardestRound').textContent = `${data.stats.hardestRound.round} (${Math.round(data.stats.hardestRound.avgScore)} bodov priemer)`;
      document.getElementById('bestRound').textContent = `${data.stats.bestRound.team} (${data.stats.bestRound.round}: ${data.stats.bestRound.score} bodov)`;
    }

    // Initialize seasons: fetch and set active season, render season dropdown
    async function initSeasons() {
      const resp = await supabase
        .from('seasons')
        .select('id, name, is_active')
        .order('name', { ascending: true });
      const seasons = resp.data;
      const seasonsError = resp.error;
      console.log('initSeasons response', resp);
      if (seasonsError) console.warn('initSeasons error', seasonsError);
      if (seasons && seasons.length) {
        const active = seasons.find(s => s.is_active) || seasons[0];
        currentSeasonId = active && active.id ? active.id : null;
      }
      renderSeasonDropdown(seasons || [], async (seasonId) => {
        // When season changes: refresh quizzes and the current view
        currentSeasonId = seasonId;
        await renderArchive();
        // If in league view, refresh it
        if (currentView === 'league') {
          const leagueData = await fetchLeague();
          renderLeagueTable(leagueData);
        } else {
          // pick first quiz of new season (if available) and render
          const qsel = document.querySelector('#quizDropdown select');
          if (qsel && qsel.options.length) {
            currentQuizId = qsel.options[0].value;
            await renderLeaderboard(currentQuizId);
          } else {
            await renderLeaderboard();
          }
        }
      });
    }

    async function renderArchive() {
      // fetch quizzes for the currently selected season (or none)
      let q = supabase
        .from('quizzes')
        .select('id, title, created_at')
        .order('created_at', { ascending: false })
        .limit(20);
      if (currentSeasonId) q = q.eq('season_id', currentSeasonId);
      const { data: quizzes } = await q;
      renderQuizDropdown(quizzes || [], async (quizId) => {
        currentQuizId = quizId;
        await renderLeaderboard(quizId);
      }, 'Kv√≠zy:');
    }

    if (!SKIP_AUTO_LOAD) {
      await initSeasons();
      await renderArchive();
      await renderLeaderboard();
    }

    // --------------------------
    // TV Mode (Fullscreen) - 16:9 projector target
    // - Grid 4 cols x 8 rows by default (4x8 = 32 tiles)
    // - Auto-refresh: polling every 5s (safe fallback if Realtime not configured)
    // - Trigger: ?tv=1 or #tv
    // --------------------------
    let tvInterval = null;
    const TV_POLL_INTERVAL = 5000;
    const TOP_COUNT = 3;
    const GRID_COLS = 4;
    const GRID_ROWS = 7;
    const GRID_COUNT = GRID_COLS * GRID_ROWS; // 28
    const MAX_TILES = TOP_COUNT + GRID_COUNT; // 31

    function renderTVTiles(entries) {
      entries = entries || [];
      const top = entries.slice(0, TOP_COUNT);
      const rest = entries.slice(TOP_COUNT, TOP_COUNT + GRID_COUNT);
      // pad rest to GRID_COUNT
      const paddedRest = rest.slice();
      while (paddedRest.length < GRID_COUNT) paddedRest.push({ team: '', total: '' });

      const wrapper = document.createElement('div');
      wrapper.className = 'tv-wrapper';

      // Top row
      const topRow = document.createElement('div');
      topRow.className = 'tv-top-row';
      for (let i = 0; i < TOP_COUNT; i++) {
        const entry = top[i] || { team: '', total: '' };
        const tile = document.createElement('div');
        tile.className = 'tv-top ' + (i === 0 ? 'tv-top--gold' : (i === 1 ? 'tv-top--silver' : 'tv-top--bronze'));
        const rank = document.createElement('div');
        rank.className = 'tv-rank-badge';
        rank.textContent = (i === 0 ? '1' : (i === 1 ? '2' : '3'));
        const team = document.createElement('div');
        team.className = 'tv-team';
        team.textContent = entry.team || '';
        const score = document.createElement('div');
        score.className = 'tv-score';
        score.textContent = (typeof entry.total === 'number' && entry.total !== 0) ? String(entry.total) : (entry.total || '');
        tile.appendChild(rank);
        tile.appendChild(team);
        tile.appendChild(score);
        topRow.appendChild(tile);
      }
      wrapper.appendChild(topRow);

      // Grid of remaining teams
      const grid = document.createElement('div');
      grid.className = 'tv-grid';
      paddedRest.forEach((e, idx) => {
        const tile = document.createElement('div');
        tile.className = 'tv-tile';
        const globalRank = TOP_COUNT + idx + 1; // 4..31
        const rankEl = document.createElement('div');
        rankEl.className = 'tv-rank-badge';
        rankEl.textContent = String(globalRank);
        const team = document.createElement('div');
        team.className = 'tv-team';
        team.textContent = e.team || '';
        const score = document.createElement('div');
        score.className = 'tv-score';
        score.textContent = (typeof e.total === 'number' && e.total !== 0) ? String(e.total) : (e.total || '');
        tile.appendChild(rankEl);
        tile.appendChild(team);
        tile.appendChild(score);
        grid.appendChild(tile);
      });
      wrapper.appendChild(grid);

      const lb = document.getElementById('leaderboard');
      if (lb) {
        lb.innerHTML = '';
        lb.appendChild(wrapper);
      }
    }

    async function fetchAndRenderTV() {
      try {
        if (currentView === 'league') {
          const data = await fetchLeague();
          const entries = (data && data.league) || [];
          renderTVTiles(entries.map(x => ({ team: x.team, total: x.total })).slice(0, MAX_TILES));
        } else {
          if (!currentQuizId) {
            const { data: quiz } = await supabase
              .from('quizzes')
              .select('id')
              .order('created_at', { ascending: false })
              .limit(1)
              .single();
            if (quiz) currentQuizId = quiz.id;
          }
          const result = await fetchLeaderboardForQuiz(currentQuizId);
          const entries = (result && result.leaderboard) || [];
          renderTVTiles(entries.map(r => ({ team: r.team, total: r.total })).slice(0, MAX_TILES));
        }
      } catch (err) {
        console.error('TV fetch error', err);
      }
    }

    function startTVAutoRefresh() {
      if (tvInterval) clearInterval(tvInterval);
      tvInterval = setInterval(fetchAndRenderTV, TV_POLL_INTERVAL);
    }

    function stopTVAutoRefresh() {
      if (tvInterval) { clearInterval(tvInterval); tvInterval = null; }
    }

    async function enterTVMode() {
      try {
        document.body.classList.add('tv-mode');
        // request fullscreen if available
        if (document.documentElement.requestFullscreen) {
          try { await document.documentElement.requestFullscreen(); } catch (e) { /* ignore */ }
        }
        await fetchAndRenderTV();
        startTVAutoRefresh();
        // hide cursor after 3s of inactivity
        let mouseTimer;
        function resetCursorTimer() {
          document.body.classList.remove('hide-cursor');
          if (mouseTimer) clearTimeout(mouseTimer);
          mouseTimer = setTimeout(() => document.body.classList.add('hide-cursor'), 3000);
        }
        document.addEventListener('mousemove', resetCursorTimer);
        resetCursorTimer();
      } catch (e) {
        console.error('Failed to enter TV mode', e);
      }
    }

    async function exitTVMode() {
      stopTVAutoRefresh();
      document.body.classList.remove('tv-mode');
      document.body.classList.remove('hide-cursor');
      try { if (document.exitFullscreen) await document.exitFullscreen(); } catch (e) { /* ignore */ }
      if (!SKIP_AUTO_LOAD) renderLeaderboard();
    }

    // Auto-enter TV mode if ?tv=1 or #tv present
    try {
      const p = new URLSearchParams(window.location.search || '');
      if (p.get('tv') === '1' || window.location.hash === '#tv') {
        setTimeout(() => enterTVMode(), 60);
      }
    } catch (e) { /* ignore */ }
    }

    // Loader: ensure config.js is loaded if it exists, then run the app
    if (typeof window !== 'undefined' && window.SUPABASE_URL && window.SUPABASE_ANON_KEY) {
      // config already present
      runApp();
    } else {
      // try to load config.js dynamically; if it fails, show actionable message
      const loader = document.createElement('script');
      loader.src = 'config.js';
      loader.onload = function () {
        try { runApp(); } catch (e) { console.error('Error running app after loading config.js', e); }
      };
      loader.onerror = function () {
        console.error('config.js not found or failed to load. Check GitHub Actions deployment and repository secrets.');
        const board = document.getElementById('leaderboard');
        if (board) {
          board.innerHTML = `
            <div style="width:75vw; max-width:900px; margin:48px auto; padding:24px; background:#3a1f2f; color:#fff; border-radius:12px; text-align:left;">
              <h2 style="margin-bottom:12px;">Konfigur√°cia ch√Ωba (deploy)</h2>
              <p>Deployed site is missing <code>config.js</code>. The GitHub Pages deploy should generate it from repository secrets.</p>
              <ol>
                <li>Confirm secrets are set in <strong>Settings ‚Üí Secrets and variables ‚Üí Actions</strong>.</li>
                <li>Check <strong>Actions</strong> tab for the latest workflow run and inspect the <em>Generate config.js</em> step for errors.</li>
                <li>Re-run the workflow or push a new commit to trigger deploy.</li>
              </ol>
              <p style="color:#ffd700">If you see this message locally, run <code>node make-config.js</code> to create <code>config.js</code>.</p>
            </div>`;
        }
      };
      document.head.appendChild(loader);
    }
  })();
  </script>
</body>
</html>
